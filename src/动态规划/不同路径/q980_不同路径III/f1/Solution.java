package 动态规划.不同路径.q980_不同路径III.f1;

/**
 * @ClassName : Solution
 * @Description :980. 不同路径 III
 * 在二维网格 grid 上，有 4 种类型的方格：
 *
 * 1 表示起始方格。且只有一个起始方格。
 * 2 表示结束方格，且只有一个结束方格。
 * 0 表示我们可以走过的空方格。
 * -1 表示我们无法跨越的障碍。
 * 返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。
 *
 *
 *
 * 示例 1：
 *
 * 输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
 * 输出：2
 * 解释：我们有以下两条路径：
 * 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
 * 2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
 * 示例 2：
 *
 * 输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]
 * 输出：4
 * 解释：我们有以下四条路径：
 * 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
 * 2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
 * 3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
 * 4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
 * 示例 3：
 *
 * 输入：[[0,1],[2,0]]
 * 输出：0
 * 解释：
 * 没有一条路能完全穿过每一个空的方格一次。
 * 请注意，起始和结束方格可以位于网格中的任意位置。
 *
 *
 * 提示：
 *
 * 1 <= grid.length * grid[0].length <= 20
 * @Author : zph
 * @Date: 2020-07-06 20:57
 * @Version : V1.0
 */
public class Solution {
    //结果
    int ans=0;
    //数据复制
    int[][] grid;
    //结束位置角标
    int tr,tc;
    //四个方向
    int[] dr={0,1,0,-1};
    int[] dc={1,0,-1,0};
    //行、列长度
    int R;
    int C;

    public int uniquePathsIII(int[][] grid) {
        this.grid=grid;
        R=grid.length;
        C=grid[0].length;
        //除了障碍物其他方格数量
        int todo=0;
        //开始位置角标
        int sr=0;
        int sc=0;
        for(int i=0;i<R;i++){
            for(int j=0;j<C;j++){
                if(grid[i][j]!=-1){
                    todo++;
                }
                if(grid[i][j]==1){
                    sr=i;
                    sc=j;
                }
                if(grid[i][j]==2){
                    tr=i;
                    tc=j;
                }

            }

        }
        dfs(sr,sc,todo);
        return  ans;
    }

    private  void dfs(int r,int c,int todo){
        todo--;
        if(todo<0){
            return;
        }
        // 到达终点
        if(r==tr&&c==tc){
           // 并且经过所有无障碍方格
            if(todo==0){
                ans++;
            }
            //无论是否全部经过都要退出
            return;
        }
        //特殊赋值，防止重复经过
        grid[r][c]=3;
        for(int k=0;k<4;k++){
            int nr=r+dr[k];
            int nc=c+dc[k];
            if(nr>=0&&nr<R&&nc>=0&&nc<C){
                //没有经过不是3，不是障碍物-1
                if(grid[nr][nc]%2==0){
                    dfs(nr,nc,todo);
                }
            }
        }

        //返原
        grid[r][c]=0;


    }


}
